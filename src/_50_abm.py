""""
The script is used to initialize and run the ABM.

input:
  exogenous_cross_sections: dict contains the synthetic homes and the parameters of the locations for generating the incomes
  parameters: dict with all the parameters of the ABM, including the length of the transient (Tb) and the length of the simulation (T)
  
output:
  variables: dict containing the data generated by the ABM. Some information are updated at each timestep, some other are stored for the whole simulation.
              the following variables are stored as time series
          "price_required_list": price required for all homes in sale
          "time_on_market": #months the homes in sale have been in sale 
          "which_homes_transacted": homes transacted at each timestep
          "successful_buyers": buyers that become housed at each timestep
          "successful_sellers": housed that become sellers at each timestep
          "unsuccessful_buyers": buyers that did not find home at each timestep
          "unsuccessful_sellers": sellers that did not sell at each timestep
          "time_unsuccessful_buying": #months buyers did not manage to buy a house
          "awarenesses_successful_buyers": awarenesses of successful buyers (at time of transaction)
          "awarenesses_successful_sellers": awarenesses of successful sellers (at time of transaction)
          "awarenesses_unsuccessful_buyers": awarenesses of unsuccessful buyers (at each time)
          "awarenesses_unsuccessful_sellers": awarenesses of unsuccessful buyers (at each time)
          "reservation_price_sellers": reservation price at each timestep
          "reservation_price_buyers": maximum price buyers can pay
          "reservation_price_unsuccessful_sellers": reservation price at each timestep
          "reservation_price_unsuccessful_buyers": maximum price buyers can pay
    
  
"""


import numpy as np
import random
import time
import pandas as pd
import sys
sys.path += ["../src"]
from _52_abm_auxiliary_functions import *
from scipy.stats import lognorm
import config
import utils
from tqdm import tqdm
import numexpr as ne


class ABM:
    def __init__(self,
      # Dictionary with all exogenous cross sections, in a consistent format
      exogenous_cross_sections,
      # Description for awarenesses
      awarenesses_scenario,
      # Dictionary with parameters
      parameters,
      # Print time it takes to execute the various parts
      print_time=False
      ):
        
      self.exogenous_cross_sections = exogenous_cross_sections
      self.awarenesses_scenario = awarenesses_scenario
      self.parameters = parameters
      self.print_time = print_time
      
      self.T = self.parameters["T"]
      self.Tb = self.parameters["burn_in"]
      self.M = self.parameters["n_homes"]
      self.N = self.M

    """"
    Initialize the ABM:
    - store the synthetic houses in ABM class
    - assign income to each agent based on spatial area
    - assign houses to agents
    - a fraction of the agents is initialized as buyer (fraction_buyer)
    - the same number of agents is initialized as seller
    - create a dataframe ag for keeping information about all agents. This dataframe will be updated at each timestep
    """
    def initialize_abm(self,seed_init):
      np.random.seed(seed_init)  
      
      da = self.exogenous_cross_sections["homes_synth_pop"]
      da.index = range(da.shape[0])
      da.rename(columns={
        'x': 'long',
        'y': 'lat'
        }, inplace=True)
      da["risk_score"] = da['scenario_Risk'].apply(lambda x: 1 if x == 0 else 0)
                            
      spatial_area_income_df = da["spatial_area_income"].value_counts().sort_index()
      spatial_area_income_counts = pd.DataFrame({'spatial_area_income':spatial_area_income_df.index, 
                                                 'freq':spatial_area_income_df.values})
      spatial_area_income_counts = (spatial_area_income_counts
                                    .merge(self.exogenous_cross_sections["df_params"]
                                           .groupby("spatial_area_income").first().reset_index(),
                                                                    how="left"))
      spatial_area_income_counts.loc[spatial_area_income_counts["loc_isp"].isna(), ["loc_isp", "scale_isp", "sigma_isp"]] = \
            self.exogenous_cross_sections["df_params_agg"][["loc_isp","scale_isp","sigma_isp"]].values
      
      ag=pd.DataFrame({"id":range(self.N),
                       "spatial_area_income":np.repeat(spatial_area_income_counts.spatial_area_income, 
                                                  spatial_area_income_counts.freq),
                       "income_cross_section":np.nan,
                       "matching":np.nan})
      ag.index = ag["id"]
      
      for i in range(len(spatial_area_income_counts)):
            
        # Assign an income to agents given their spatial area income
        sp = spatial_area_income_counts.spatial_area_income[i]
        params = spatial_area_income_counts[["loc_isp","scale_isp","sigma_isp"]].iloc[i]
        draws = self.assign_income_to_agents(spatial_area_income_counts.freq[i], params)
        ag.loc[ag["spatial_area_income"]==sp,"income_cross_section"] = draws
        
        # Assign richest agents to most expensive homes
        ix_homes_in_sp = da.index[da["spatial_area_income"]==sp].values
        prices_homes_in_sp = da.loc[ix_homes_in_sp,"price_hedonic"].values
        ix_agents_in_sp = ag.loc[ag["spatial_area_income"]==sp,"id"].values
        incomes_agents_in_sp = ag.loc[ag["spatial_area_income"]==sp,"income_cross_section"].values
        ordered_ix_agents_in_sp = ix_agents_in_sp[np.argsort(incomes_agents_in_sp)]
        ordered_ix_homes_in_sp = ix_homes_in_sp[np.argsort(prices_homes_in_sp)]
        ag.loc[ordered_ix_agents_in_sp,"matching"] = ordered_ix_homes_in_sp  
        
      # Randomly initialize which agent is housed and which is seller, the agents at the end are all buyers
      n_buyers = int(self.parameters["fraction_buyers"]*self.N)
      params = self.exogenous_cross_sections["df_params_agg"][["loc_isp","scale_isp","sigma_isp"]]
      draws = self.assign_income_to_agents(n_buyers, params)
      ag=pd.concat([ag,
               pd.DataFrame({"id":range(self.N,self.N+n_buyers),
                       "spatial_area_income":np.nan,\
                       "income_cross_section":draws, 
                       "matching":np.random.randint(0,self.M,n_buyers)})])
      ag.index = ag["id"]
      ag = ag[["id","income_cross_section","matching"]]
      ag["matching"] = ag["matching"].astype(int)
      ag["matching_copy"] = ag["matching"]
        
      n_sellers = n_buyers
      states_residents = np.concatenate([[0 for i in range(self.N-n_sellers)],[1 for i in range(n_sellers)]])
      np.random.shuffle(states_residents)
      state_list = np.concatenate([list(states_residents),[2 for i in range(n_buyers)]])
      ag["state"] = state_list
      ag["reservation_price"] = np.nan
      ag["time_unsuccessful_buying"] = np.nan
      ag.loc[ag.state==2,"time_unsuccessful_buying"] = 0
      ag["awarenesses"] = np.nan

      vars_init = {
          "da":da,
          "ag":ag,
          }
          
      return vars_init

    def assign_income_to_agents(self, n_agents, params):
        return lognorm.rvs(s=params["sigma_isp"], loc=params["loc_isp"], \
                           scale=params["scale_isp"], size=n_agents)
    
    """
    at each timestep update the awarenesses of the agents
    this update depend on the awarenesses_scenario
    parameters["awarenesses_input"] contains the timeseries of the awarenesses, aljust accounting for the predicted floods 
    """
    def determine_awarenesses_at_t(self,t,ag):
      
      if self.awarenesses_scenario == "fixed":
        awarenesses_list = np.full(ag.shape[0],self.parameters["awarenesses_input"])
        
      if self.awarenesses_scenario == "fixed_by_income_group":
        number_income_groups = len(self.parameters["awarenesses_input"])
        quantiles_income_groups = np.linspace(0,1,number_income_groups+1)
        x = ag["income_cross_section"]
        agents_quantile = pd.qcut(x,q=quantiles_income_groups, 
          labels=["Q"+str(i+1) for i in range(number_income_groups)])
        awarenesses_list = np.array([self.parameters["awarenesses_input"][agent_quantile] \
          for agent_quantile in agents_quantile]) 
          
      if self.awarenesses_scenario == "timeseries":
        awarenesses_list = np.full(ag.shape[0],self.parameters["awarenesses_input"][t])
      #Still need to add more scenarios, e.g. income-based  
      
      return awarenesses_list


    def update_dataframe_with_new_buyers(self, variables, vars_init):  
      #Update ag dataframe to reflect the new buyers 
      ag = variables["ag"].copy()
      
      # First, replace agents that have been too long on the market -> they rent
      time_unsuccessful_buying_list = ag["time_unsuccessful_buying"]
      ix_buyers_more_than_x_steps_on_the_market = np.where(time_unsuccessful_buying_list> \
        self.parameters["steps_buyers_on_the_market"])[0]
      ag.loc[ix_buyers_more_than_x_steps_on_the_market] = np.nan
      
      # Now, give new buyers the right features
      ix_new_buyers = np.where(ag["id"].isna())[0]
      params = self.exogenous_cross_sections["df_params_agg"][["loc_isp","scale_isp","sigma_isp"]]
      draws = self.assign_income_to_agents(len(ix_new_buyers), params)
                                         
      # Assign matching at random
      ag.loc[ix_new_buyers,"income_cross_section"] = draws
      ag.loc[ix_new_buyers,"matching"] = np.random.randint(0,self.M,len(ix_new_buyers))  
      ag.loc[ix_new_buyers,"state"] = 2
      ag.loc[ix_new_buyers,"time_unsuccessful_buying"] = 0
      ix_id_nan = ag["id"].isna()
      ag.loc[ix_id_nan,"id"] = list(range(int(ag["id"].max()+1),int(ag["id"].max()+sum(ix_id_nan)+1)))
      ag["matching"] = ag["matching"].astype(int)
      ag["id"] = ag["id"].astype(int)

      return ag


    def determine_sellers_prices(self,variables,vars_init,indexes_new_homes_on_sale):
      #Determine average ratio between transaction and hedonic price within lookup_distance and 
      #steps_back_prices. 
      #If the lists do not have steps_back_prices yet, consider the first elements
      length_list = len(variables["which_homes_transacted"])
      if length_list < self.parameters["steps_back_price_estimation"]:
        indexes_steps_back_prices = range(length_list)
      else:
        indexes_steps_back_prices = range(length_list-self.parameters["steps_back_price_estimation"],length_list)
      
      indexes_homes_transacted_in_previous_steps = \
        np.concatenate([variables["which_homes_transacted"][tau] for tau in indexes_steps_back_prices])
      indexes_homes_transacted_in_previous_steps = np.array(indexes_homes_transacted_in_previous_steps,dtype=int)
        
      if len(indexes_homes_transacted_in_previous_steps)>0:
        ratios_homes_transacted_in_previous_steps = \
          np.concatenate([variables["prices_transactions_this_step"][tau]/\
                      vars_init["da"]["price_hedonic"][variables["which_homes_transacted"][tau]]\
                      for tau in indexes_steps_back_prices])
        coordinates_new_homes_on_sale = vars_init["da"][["lat","long"]].values[indexes_new_homes_on_sale]
        coordinates_homes_transacted_in_previous_steps = vars_init["da"][["lat","long"]].values[indexes_homes_transacted_in_previous_steps]
        distances_homes_transacted_in_previous_steps = distance_matrix(coordinates_new_homes_on_sale,\
                                                                       coordinates_homes_transacted_in_previous_steps)
        
        mask = distances_homes_transacted_in_previous_steps < self.parameters["lookup_distance"]
        masked_ratios = np.where(mask, ratios_homes_transacted_in_previous_steps, np.nan)
        valid_rows_mask = np.isfinite(masked_ratios).any(axis=1)
        
        ratios_new_homes_on_sale = np.full(masked_ratios.shape[0], 1.)
        ratios_new_homes_on_sale[valid_rows_mask] = np.nanmean(masked_ratios[valid_rows_mask], axis=1)
                
      else:
        ratios_new_homes_on_sale = np.ones(len(indexes_new_homes_on_sale))
        
      price_required_list = variables["price_required_list"][-1].copy()
      time_on_market_list = variables["time_on_market"][-1].copy()
      price_required_list[indexes_new_homes_on_sale] = vars_init["da"]["price_hedonic"][indexes_new_homes_on_sale]*\
        ratios_new_homes_on_sale*(1+self.parameters["markup"])
      time_on_market_list[indexes_new_homes_on_sale] = 0

      return price_required_list, time_on_market_list

    """
    buyers assign a preference score to each house.
    This score is the aggregation of 4 contributions
    - distance score: agents prefer houses that are closest to previous location 
    - quality score: agents prefer houses with higher quality
    - price score: agents assign a score based on quality / price ratio and on the maximum price they can afford
    - risk score: agents assign a score based on their awarenesses and on the flood risk of the area
    finally, agents they compute a weighted average of the 4 scores for each houses
    preference_matrix is a matrix of dimensions (#buyers, #houses on market) with all buyers preferences for all available houses
    preference_matrix rows sum to 1. Hence, each entry i,j is the probability that buyer i selects house j
    last column of preference_matrix is no_buy_option, so it is the probability that buyer i does not select any house    
    """
    def buyers_decision(self,t,variables,vars_init,ag,price_required_list,
                        indexes_homes_on_sale,ix_buyers,ix_sellers):
      
      #first term in utility: distance
      indexes_previous_homes_buyers = ag["matching"][ix_buyers].values
      coordinates_buyers = vars_init["da"][["lat","long"]].values[indexes_previous_homes_buyers]
      coordinates_sellers = vars_init["da"][["lat","long"]].values[indexes_homes_on_sale]
      distance_buyers_sellers = distance_matrix(coordinates_buyers,coordinates_sellers)
      params_distance = -self.parameters["coefficient_distance"]*distance_buyers_sellers
      preference_distance = ne.evaluate("exp(params_distance)")
      # preference_distance = np.exp(-self.parameters["coefficient_distance"]*distance_buyers_sellers)
  
      #second term in utility: quality-price tradeoff
      attractiveness_homes_on_sale = vars_init["da"]["price_hedonic"][indexes_homes_on_sale]/max(vars_init["da"]["price_hedonic"])
      attractiveness_homes_on_sale_matrix = np.tile(attractiveness_homes_on_sale,(len(ix_buyers),1))
      reservation_price_matrix = np.tile(np.array([ag["reservation_price"][ix_buyers]]).transpose(),(1,len(ix_sellers)))
      price_required_matrix = np.tile(price_required_list[indexes_homes_on_sale],(len(ix_buyers),1))
      utility_price_matrix = np.maximum(0,1-price_required_matrix/reservation_price_matrix)
      preference_quality_price = (attractiveness_homes_on_sale_matrix**self.parameters["weight_utility"][1])*\
                                (utility_price_matrix**self.parameters["weight_utility"][2])
      
      #third term in utility: climate risk
      awarenesses_matrix = np.tile(ag["awarenesses"].values[ix_buyers][:, np.newaxis],(1,len(ix_sellers)))
      risk_matrix = np.tile((vars_init["da"]["risk_score"][indexes_homes_on_sale].values+1)/2,(len(ix_buyers),1))
      preference_risk = risk_matrix ** awarenesses_matrix
      preference_matrix = (preference_distance**self.parameters["weight_utility"][0])*\
                          (preference_quality_price)*\
                          (preference_risk**self.parameters["weight_utility"][3])
      if len(preference_matrix[preference_matrix>0])>0:
        no_buy_option = np.quantile(preference_matrix[preference_matrix>0],self.parameters["no_buy_option_quantile"])
      else:
        no_buy_option = 1
      
      preference_matrix = np.c_[preference_matrix,np.full(preference_matrix.shape[0],no_buy_option).transpose()]

      preference_matrix = preference_matrix/preference_matrix.sum(axis=1)[:,None]

      return preference_matrix

    """
    for each buyer sample a house with probability proportional to preference_matrix
    if several buyers selected the same house, select only one of them at random
    """
    def matching_buyers_sellers(self,preference_matrix):
      
      choice_matrix = np.array([np.random.multinomial(n=1,pvals=preference_matrix[i,:]) for i in range(preference_matrix.shape[0])])
      b,s=np.nonzero(choice_matrix[:,0:(choice_matrix.shape[1]-1)])
      s_unique, ind, c = np.unique(s, return_counts=True, return_index=True)
      s_unique_ordered = (s_unique[c==1])[np.argsort(ind[c==1])]
      duplicate_sellers = s_unique[c>1]
      ix=np.isin(s,duplicate_sellers)
      b_unique = b[np.logical_not(ix)]
      other_b = [np.random.choice(b[s==duplicate_sellers[i]]) for i in range(len(duplicate_sellers))]
      b_unique = np.concatenate([b_unique,other_b]).astype(int)
      s_unique = np.concatenate([s_unique_ordered,duplicate_sellers]).astype(int)

      return b_unique, s_unique

    """
    initialize variables in ABM
    variables is updated at each timestep
    """
    def setup_variables(self, seed_run, vars_init):

      np.random.seed(seed_run)
        
      price_required_list = np.array([np.nan for i in range(self.M)])
      price_required_list_copy = price_required_list.copy()
      indexes_homes_on_sale = vars_init["ag"]["matching"][vars_init["ag"]["state"]==1]
      price_required_list[indexes_homes_on_sale] = vars_init["da"]["price_hedonic"][indexes_homes_on_sale]
      time_on_market_list = np.array([np.nan for i in range(self.M)])
      time_on_market_list[indexes_homes_on_sale] = 0
      
      variables = {}
      variables["ag"] = vars_init["ag"].copy()
      variables["price_required_list"] = [price_required_list]
      variables["price_required_list_copy"] = [price_required_list_copy]
      variables["time_on_market"] = [time_on_market_list]
      variables["time_on_market_copy"] = [time_on_market_list]
      variables["prices_transactions_this_step"] = [[]]
      variables["which_homes_transacted"] = [[]]
      variables["which_homes_not_sold"] = [[]]
      # variables["preference_matrix"] = [[]]
      variables["preference_matrix"] = []
      variables["successful_buyers"] = [[]]
      variables["successful_sellers"] = [[]]
      variables["unsuccessful_buyers"] = [[]]
      variables["unsuccessful_sellers"] = [[]]
      variables["time_unsuccessful_buying"] = [[]]

      variables["awarenesses_successful_buyers"] = [[]]
      variables["awarenesses_successful_sellers"] = [[]]
      variables["awarenesses_unsuccessful_buyers"] = [[]]
      variables["awarenesses_unsuccessful_sellers"] = [[]]
      variables["reservation_price_sellers"] = [[]]
      variables["reservation_price_buyers"] = [[]]
      variables["reservation_price_unsuccessful_sellers"] = [[]]
      variables["reservation_price_unsuccessful_buyers"] = [[]]
      
      return variables

    """
    first, run the ABM for the transient (the burn-in phase)
    in this phase all the variables are updated, but the timestep remains 0
    this way, the awarenesses are not updated
    """
    def run_until_end_transient(self,seed_run,vars_init, hide_progress_transient = True):
      
      variables = self.setup_variables(seed_run, vars_init)
      #Burn in
      for t_artificial in tqdm(range(self.Tb), disable = hide_progress_transient):
          variables=\
            self.run_one_step(0,variables,vars_init,\
                        print_time=False)
      return variables


    
    """
    run the ABM, updating both the variables and the timestep (and the awarenesses)
    """
    def run(self,seed_run,vars_init, hide_progress = False, hide_progress_transient = True):
      
      variables = self.run_until_end_transient(seed_run,vars_init, hide_progress_transient = hide_progress_transient)
      
      for t in tqdm(range(1,self.T+1), disable = hide_progress):
          
          variables = self.run_one_step(t,variables,vars_init,
                                        print_time=False)

      return variables

    """
    run a single step of the ABM
    - successful sellers become buyers and fix their reservation price
    - all agents update their awarenesses based on awarenesses_input (thus the flood memory)
    - some housed agents become sellers (based on probability_sell) and assign prices to their homes (based on market, hedonic price of their home and markup)
    - old sellers decrease the price of the houses on market
    - buyers assign preference scores to the houses on market
    - buyers and sellers are matched, based on preference_matrix, transactions occur
    - successful buyers and successful sellers change state
    - all the variables are updated based on the last transactions
    """
    def run_one_step(self,t,variables,vars_init,print_time=False):
      if self.print_time:
        t0=time.time()

      # Get new dataframe of agents that includes new buyers
      ag = self.update_dataframe_with_new_buyers(variables,vars_init)

      # Get updated reservation prices that take into account the current step
      ag["reservation_price"] = maximum_housing_price(
          monthly_individual_income=ag["income_cross_section"].values/12,
          H=1,
          s=self.parameters["monthly_payment_to_income"],
          Ï†=1-self.parameters["loan_to_value"],
          r=self.parameters["interest_rates"]/12)
      
      # Get updated incomes and reservation prices that take into account the current step and the awarenesses scenario
      awarenesses_list = self.determine_awarenesses_at_t(t,ag)
      ag["awarenesses"] = awarenesses_list
      
      if self.print_time:
        t1=time.time()
        print(t1-t0)
            
      #Change housed -> sellers
      old_state_list = ag["state"].copy()
      l=old_state_list[old_state_list==0]
      ag.loc[ag["state"]==0,"state"] = [1 if np.random.random() < self.parameters["probability_sell"] \
                                          else 0 for i in range(len(l))]
      ix_sellers = np.where(ag["state"]==1)[0]
      ix_new_sellers = np.where((ag["state"]==1) & (old_state_list==0))[0]
      indexes_homes_on_sale = ag["matching"][ix_sellers].values
      indexes_new_homes_on_sale = ag["matching"][ix_new_sellers].values

      #Get updated asking prices and time on market lists
      price_required_list,time_on_market_list = self.determine_sellers_prices(variables,vars_init,indexes_new_homes_on_sale)
  
      if self.print_time:
        t2=time.time()
        print(t2-t1)

      #Choice of home by buyers
      ix_buyers = np.where(ag["state"]==2)[0]
      if len(ix_buyers)>0 and len(ix_sellers)>0:
        preference_matrix = self.buyers_decision(t,variables,vars_init,ag,price_required_list,\
          indexes_homes_on_sale,ix_buyers,ix_sellers)
      else:
        preference_matrix = np.array([])
      
      if self.print_time:
        t3=time.time()
        print(t3-t2)

      #Matching between buyers and sellers
      if len(ix_buyers)>0 and len(ix_sellers)>0:
        b_unique, s_unique = self.matching_buyers_sellers(preference_matrix)
        buyers_selected = ix_buyers[b_unique]
        sellers_selected = ix_sellers[s_unique]
      else:
        buyers_selected, sellers_selected = np.array([]), np.array([])

      if self.print_time:
        t4=time.time()
        print(t4-t3)

      
      #Update states and related variables taking this matching into account
      ag["old_state"] = ag["state"].copy()
      ag.loc[buyers_selected, 'state'] = 0
    #   ag.loc[ag["state"] != 2,"time_unsuccessful_buying"] = np.nan
      unsuccessful_buyers = np.where(ag["state"]==2)[0]
      ag.loc[unsuccessful_buyers, "time_unsuccessful_buying"] = ag.loc[unsuccessful_buyers, "time_unsuccessful_buying"].fillna(0) + 1
      

      ag.loc[sellers_selected, 'state'] = 2
    #   ag.loc[sellers_selected, 'time_unsuccessful_buying'] = ag.loc[sellers_selected, 'time_unsuccessful_buying'].fillna(0)
      unsuccessful_sellers = np.where(ag["state"]==1)[0]
      
      prices_transactions_this_step = price_required_list[ag["matching"][sellers_selected]]
      price_required_list_copy = price_required_list.copy()
      price_required_list[ag["matching"][sellers_selected]] = np.nan
      time_on_market_list_copy = time_on_market_list.copy()
      time_on_market_list_copy = time_on_market_list_copy + 0.5
      time_on_market_list[ag["matching"][sellers_selected]] = np.nan
      which_homes_transacted = ag["matching"][sellers_selected].copy()
      which_homes_not_sold = ag["matching"][unsuccessful_sellers].copy()
      ag["matching_old"] = ag["matching"]
      ag.loc[buyers_selected, 'matching'] = ag.loc[sellers_selected, 'matching'].values

      price_required_list = self.parameters["price_reduction"] * price_required_list
      time_on_market_list = time_on_market_list + 1
  
      variables["ag"] = ag.copy()
      variables["price_required_list"].append(price_required_list)
      variables["price_required_list_copy"].append(price_required_list_copy)
      variables["time_on_market"].append(time_on_market_list)
      variables["time_on_market_copy"].append(time_on_market_list_copy)
      variables["prices_transactions_this_step"].append(prices_transactions_this_step)
      variables["which_homes_transacted"].append(which_homes_transacted)
      variables["which_homes_not_sold"].append(which_homes_not_sold)
      # variables["preference_matrix"].append(preference_matrix)
      variables["preference_matrix"] = preference_matrix
      variables["successful_buyers"].append(buyers_selected)
      variables["successful_sellers"].append(sellers_selected)
      
      variables["unsuccessful_buyers"].append(unsuccessful_buyers)
      variables["unsuccessful_sellers"].append(unsuccessful_sellers)
      variables["time_unsuccessful_buying"].append(np.array(ag.loc[unsuccessful_buyers, "time_unsuccessful_buying"]))

      variables["awarenesses_successful_buyers"].append(list(ag.loc[buyers_selected, "awarenesses"]))
      variables["awarenesses_successful_sellers"].append(list(ag.loc[sellers_selected, "awarenesses"]))
      variables["awarenesses_unsuccessful_buyers"].append(list(ag.loc[unsuccessful_buyers, "awarenesses"]))
      variables["awarenesses_unsuccessful_sellers"].append(list(ag.loc[unsuccessful_sellers, "awarenesses"]))
      variables["reservation_price_sellers"].append(list(ag.loc[sellers_selected, "reservation_price"]))
      variables["reservation_price_buyers"].append(list(ag.loc[buyers_selected, "reservation_price"]))
      variables["reservation_price_unsuccessful_sellers"].append(list(ag.loc[unsuccessful_sellers, "reservation_price"]))
      variables["reservation_price_unsuccessful_buyers"].append(list(ag.loc[unsuccessful_buyers, "reservation_price"]))
      
      
        
      if (ag["old_state"]==2).sum() != int(self.parameters["fraction_buyers"]*self.N):
        print("Problem: number buyers not corresponding at t "+str(t))
        print((ag["old_state"]==2).sum())
        print(number_buyers)

      if self.print_time:
        t5=time.time()
        print(t5-t4)
        print("end step, time "+str(t5-t1))

      
        
      return variables
    